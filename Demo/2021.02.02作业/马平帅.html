<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020.02.02作业</title>
</head>

<body>
    <!--
        选择题：
            1.ABCD
            2.ABC
            3.C
            4.BC
            5.A
        简答题：
            1.构造函数模式：
                1.创建一个新的对象，这个对象的类型是 object；
                2.设置这个新的对象的内部、可访问性和属性为新构造函数中设置的；
                3.执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性； 
                4.返回新创建的对象（除非构造方法中返回的是‘无原型’）。
                5.在创建新对象成功之后，如果调用一个新对象没有的属性的时候，JavaScript 会延原型链向止逐层查找对应的内容。这类似于传统的‘类继承’。
            2.
                1、优点：解决工厂模式(所谓工厂模式就是像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，
                就能生产类似的产品)不是用new关键字来创建对象的弊端，解决工厂模式创建的实例和模型没有内在联系的问题;
                3、缺点：无法解决工厂模式不同实例对应于不同内存的问题（内存浪费），这个用原型模式可以解决;
        -->
    <script type="text/javascript">
        function student(姓名, 年龄, 自我介绍) {
            this.姓名 = 姓名;
            this.年龄 = 年龄;
            this.自我介绍 = 自我介绍;
            this.show_self = function () {
                console.log(`姓名：${this.姓名}`);
                console.log(`年龄：${this.年龄}`);
                console.log(`自我介绍：${this.自我介绍}`);
            }
        }

        var student_A = new student("高乐乐", "15", "我叫高乐乐，我是一个初中三年级的学生，我非常喜欢音乐和打篮球");
        student_A.show_self();

        function fn() {
            var num = 11;
            return function () {
                var n = 0;
                console.log(++n);
                console.log(++num);
            }
        }
        var fn1 = fn();
        fn1();
        fn1();
        //运行结果：
        //1
        //12
        //1
        //13
        //分析：n是一个局部变量，在函数内部，函数return后就会销毁，num在fn的内部，但是在return函数的外部，
        //所以在return后会被保留，也就是闭包，直观的说就是形成一个不销毁的栈环境。
    </script>
</body>

</html>
